"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isAnyUnknown = exports.unPromisify = exports.arrayContainsSet = exports.getFilenameForImportSpecifier = exports.getFilenameForImportDeclaration = exports.storeExtractedSymbol = exports.gatherImports = exports.getFilenamesForSymbol = exports.getLogicPathString = exports.extractImportedActions = exports.cleanDuplicateAnyNodes = exports.getActionTypeCreator = exports.toSpaces = exports.getParameterDeclaration = exports.getAndGatherTypeNodeForDefaultValue = exports.getTypeNodeForNode = exports.isKeaCall = exports.programFromSource = exports.sourceToSourceFile = exports.logicSourceToLogicType = void 0;
const ts = require("typescript");
const path = require("path");
const ts_clone_node_1 = require("@wessberg/ts-clone-node");
const visit_1 = require("./visit/visit");
const print_1 = require("./print/print");
const typescript_1 = require("typescript");
function logicSourceToLogicType(logicSource, appOptions) {
    const program = programFromSource(logicSource);
    const [parsedLogic] = (0, visit_1.visitProgram)(program);
    return (0, print_1.parsedLogicToTypeString)(parsedLogic, appOptions);
}
exports.logicSourceToLogicType = logicSourceToLogicType;
function sourceToSourceFile(sourceCode, filename = 'logic.ts') {
    return ts.createSourceFile(filename, sourceCode, ts.ScriptTarget.ES5, true);
}
exports.sourceToSourceFile = sourceToSourceFile;
function programFromSource(sourceCode) {
    const options = {};
    const compilerHost = ts.createCompilerHost(options);
    compilerHost.getSourceFile = (fileName) => (fileName === 'logic.ts' ? sourceToSourceFile(sourceCode) : undefined);
    return ts.createProgram(['logic.ts'], options, compilerHost);
}
exports.programFromSource = programFromSource;
function isKeaCall(node, checker) {
    if (!ts.isIdentifier(node)) {
        return false;
    }
    if (!node.parent || !ts.isCallExpression(node.parent)) {
        return false;
    }
    const symbol = checker.getSymbolAtLocation(node);
    if (!symbol || symbol.getName() !== 'kea') {
        return false;
    }
    const input = node.parent.arguments[0];
    if (!input || !ts.isObjectLiteralExpression(input)) {
        return false;
    }
    return true;
}
exports.isKeaCall = isKeaCall;
function getTypeNodeForNode(node, checker) {
    let typeNode;
    if (node) {
        if (ts.isAsExpression(node)) {
            typeNode = node.type;
            if (ts.isParenthesizedTypeNode(typeNode)) {
                typeNode = typeNode.type;
            }
        }
        else if ((node === null || node === void 0 ? void 0 : node.kind) === typescript_1.SyntaxKind.TrueKeyword || (node === null || node === void 0 ? void 0 : node.kind) === typescript_1.SyntaxKind.FalseKeyword) {
            typeNode = typescript_1.factory.createKeywordTypeNode(typescript_1.SyntaxKind.BooleanKeyword);
        }
        else if (ts.isStringLiteralLike(node)) {
            typeNode = typescript_1.factory.createKeywordTypeNode(typescript_1.SyntaxKind.StringKeyword);
        }
        else if (ts.isNumericLiteral(node)) {
            typeNode = typescript_1.factory.createKeywordTypeNode(typescript_1.SyntaxKind.NumberKeyword);
        }
        else if (ts.isArrayLiteralExpression(node) && node.elements.length === 0) {
            typeNode = typescript_1.factory.createArrayTypeNode(typescript_1.factory.createKeywordTypeNode(typescript_1.SyntaxKind.AnyKeyword));
        }
        else {
            typeNode = checker.typeToTypeNode(checker.getTypeAtLocation(node), undefined, undefined);
        }
    }
    else {
        typeNode = typescript_1.factory.createKeywordTypeNode(typescript_1.SyntaxKind.AnyKeyword);
    }
    return typeNode;
}
exports.getTypeNodeForNode = getTypeNodeForNode;
function getAndGatherTypeNodeForDefaultValue(defaultValue, checker, parsedLogic) {
    const typeNode = getTypeNodeForNode(defaultValue, checker);
    gatherImports(typeNode, checker, parsedLogic);
    return (0, ts_clone_node_1.cloneNode)(typeNode);
}
exports.getAndGatherTypeNodeForDefaultValue = getAndGatherTypeNodeForDefaultValue;
function getParameterDeclaration(param) {
    return typescript_1.factory.createParameterDeclaration(undefined, undefined, undefined, typescript_1.factory.createIdentifier(param.name.getText()), param.initializer || param.questionToken ? typescript_1.factory.createToken(typescript_1.SyntaxKind.QuestionToken) : undefined, (0, ts_clone_node_1.cloneNode)(param.type || typescript_1.factory.createKeywordTypeNode(typescript_1.SyntaxKind.AnyKeyword)), undefined);
}
exports.getParameterDeclaration = getParameterDeclaration;
const toSpaces = (key) => key.replace(/(?:^|\.?)([A-Z])/g, (x, y) => ' ' + y.toLowerCase()).replace(/^ /, '');
exports.toSpaces = toSpaces;
function getActionTypeCreator(parsedLogic) {
    return function (actionName) {
        return `${(0, exports.toSpaces)(actionName)} (${parsedLogic.pathString})`;
    };
}
exports.getActionTypeCreator = getActionTypeCreator;
function cleanDuplicateAnyNodes(reducers) {
    let newReducers = {};
    for (const reducer of reducers) {
        if (!newReducers[reducer.name] || !isAnyUnknown(reducer.typeNode)) {
            newReducers[reducer.name] = reducer;
        }
    }
    return Object.values(newReducers);
}
exports.cleanDuplicateAnyNodes = cleanDuplicateAnyNodes;
function extractImportedActions(actionObjects, checker, parsedLogic) {
    var _a;
    let extraActions = {};
    if (ts.isObjectLiteralExpression(actionObjects)) {
        for (const property of actionObjects.properties) {
            if (ts.isComputedPropertyName(property.name)) {
                let propertyExpression = property.name.expression;
                if (ts.isPropertyAccessExpression(propertyExpression)) {
                    const { name, expression } = propertyExpression;
                    const actionName = name.escapedText;
                    const nameSymbol = checker.getSymbolAtLocation(property.name);
                    let actionType = nameSymbol.escapedName;
                    if (ts.isPropertyAccessExpression(expression)) {
                        const logicForAction = ts.isCallExpression(expression.expression)
                            ? expression.expression.expression
                            : expression.expression;
                        const symbol = checker.getSymbolAtLocation(logicForAction);
                        const symbolType = checker.getTypeOfSymbolAtLocation(symbol, logicForAction);
                        const actionCreatorsProperty = symbolType
                            .getProperties()
                            .find((p) => p.escapedName === 'actionCreators');
                        const actionCreators = actionCreatorsProperty === null || actionCreatorsProperty === void 0 ? void 0 : actionCreatorsProperty.valueDeclaration;
                        if (actionCreators &&
                            ts.isPropertySignature(actionCreators) &&
                            ts.isTypeLiteralNode(actionCreators.type)) {
                            const actionCreator = actionCreators.type.members.find((m) => { var _a; return ((_a = m.name) === null || _a === void 0 ? void 0 : _a.escapedText) === actionName; });
                            if (actionCreator &&
                                ts.isPropertySignature(actionCreator) &&
                                ts.isFunctionTypeNode(actionCreator.type)) {
                                const type = checker.getTypeFromTypeNode(actionCreator.type);
                                const signature = type.getCallSignatures()[0];
                                const sigReturnType = signature.getReturnType();
                                const sigReturnTypeNode = checker.typeToTypeNode(sigReturnType, undefined, typescript_1.NodeBuilderFlags.NoTruncation);
                                gatherImports(sigReturnTypeNode, checker, parsedLogic);
                                if (actionType === '__computed') {
                                    if (ts.isTypeNode(actionCreator.type) && ts.isTypeNode(actionCreator.type.type)) {
                                        const m = (_a = actionCreator.type.type.members) === null || _a === void 0 ? void 0 : _a.find((m) => { var _a; return ((_a = m.name) === null || _a === void 0 ? void 0 : _a.getText()) === 'type'; });
                                        if (ts.isPropertySignature(m) && ts.isLiteralTypeNode(m.type)) {
                                            const str = m.type.getText();
                                            if (str) {
                                                actionType = str.substring(1, str.length - 1);
                                            }
                                        }
                                    }
                                }
                                extraActions[actionType] = (0, ts_clone_node_1.cloneNode)(actionCreator.type);
                            }
                        }
                    }
                }
            }
        }
    }
    return extraActions;
}
exports.extractImportedActions = extractImportedActions;
function getLogicPathString(appOptions, fileName) {
    let cwd = process.cwd();
    if (appOptions === null || appOptions === void 0 ? void 0 : appOptions.rootPath) {
        cwd = path.resolve(cwd, appOptions.rootPath);
    }
    const pathString = path
        .relative(cwd, fileName)
        .replace(/^.\//, '')
        .replace(/\.[jt]sx?$/, '')
        .replace(/\//g, '.');
    return pathString;
}
exports.getLogicPathString = getLogicPathString;
function getFilenamesForSymbol(symbol) {
    return ((symbol === null || symbol === void 0 ? void 0 : symbol.declarations) || [])
        .map((d) => d.getSourceFile().fileName)
        .filter((str) => !str.includes('/node_modules/typescript/lib/lib'));
}
exports.getFilenamesForSymbol = getFilenamesForSymbol;
function gatherImports(input, checker, parsedLogic) {
    if (!input) {
        return;
    }
    function getImports(requestedNode) {
        var _a, _b;
        let node = requestedNode;
        if (ts.isTypeReferenceNode(node)) {
            let typeRootName;
            if (((_a = node.typeName) === null || _a === void 0 ? void 0 : _a.kind) === typescript_1.SyntaxKind.FirstNode) {
                try {
                    typeRootName = node.typeName.getFirstToken().getText();
                }
                catch (e) {
                    typeRootName = (_b = node.typeName.left) === null || _b === void 0 ? void 0 : _b.escapedText;
                }
            }
            const symbol = checker.getSymbolAtLocation(node.typeName) || node.typeName.symbol;
            if (symbol) {
                storeExtractedSymbol(symbol, checker, parsedLogic, typeRootName);
            }
        }
        ts.forEachChild(requestedNode, getImports);
    }
    getImports(input);
}
exports.gatherImports = gatherImports;
function storeExtractedSymbol(symbol, checker, parsedLogic, typeRootName) {
    var _a;
    const declaration = (_a = symbol.getDeclarations()) === null || _a === void 0 ? void 0 : _a[0];
    if (declaration && ts.isImportSpecifier(declaration)) {
        const importFilename = getFilenameForImportSpecifier(declaration, checker);
        if (importFilename) {
            addTypeImport(parsedLogic, importFilename, typeRootName || declaration.getText());
        }
        else {
            parsedLogic.typeReferencesInLogicInput.add(typeRootName || declaration.getText());
        }
        return;
    }
    const files = getFilenamesForSymbol(symbol);
    if (files[0]) {
        if (ts.isTypeAliasDeclaration(declaration) ||
            ts.isInterfaceDeclaration(declaration) ||
            ts.isEnumDeclaration(declaration) ||
            ts.isClassDeclaration(declaration)) {
            if (files[0] === parsedLogic.fileName) {
                parsedLogic.typeReferencesInLogicInput.add(typeRootName || declaration.name.getText());
            }
            else {
                addTypeImport(parsedLogic, files[0], typeRootName || declaration.name.getText());
            }
        }
    }
}
exports.storeExtractedSymbol = storeExtractedSymbol;
function getFilenameForImportDeclaration(checker, importNode) {
    const moduleSymbol = checker.getSymbolAtLocation(importNode.moduleSpecifier);
    const otherSourceFile = moduleSymbol === null || moduleSymbol === void 0 ? void 0 : moduleSymbol.getDeclarations()[0].getSourceFile();
    if (otherSourceFile) {
        return otherSourceFile.fileName || importNode.moduleSpecifier.getText();
    }
}
exports.getFilenameForImportDeclaration = getFilenameForImportDeclaration;
function getFilenameForImportSpecifier(declaration, checker) {
    let importNode = declaration;
    while (importNode && !ts.isImportDeclaration(importNode)) {
        importNode = importNode.parent;
    }
    if (ts.isImportDeclaration(importNode)) {
        return getFilenameForImportDeclaration(checker, importNode);
    }
}
exports.getFilenameForImportSpecifier = getFilenameForImportSpecifier;
function addTypeImport(parsedLogic, file, typeName) {
    if (!parsedLogic.typeReferencesToImportFromFiles[file]) {
        parsedLogic.typeReferencesToImportFromFiles[file] = new Set();
    }
    parsedLogic.typeReferencesToImportFromFiles[file].add(typeName.split('.')[0]);
}
function arrayContainsSet(array, setToContain) {
    const arraySet = new Set(array);
    for (const str of setToContain) {
        if (!arraySet.has(str)) {
            return false;
        }
    }
    return true;
}
exports.arrayContainsSet = arrayContainsSet;
function unPromisify(node) {
    var _a, _b;
    if (ts.isTypeReferenceNode(node) && ((_a = node.typeName) === null || _a === void 0 ? void 0 : _a.escapedText) === 'Promise') {
        return (_b = node.typeArguments) === null || _b === void 0 ? void 0 : _b[0];
    }
    return node;
}
exports.unPromisify = unPromisify;
function isAnyUnknown(node) {
    if (!node) {
        return true;
    }
    const unPromised = unPromisify(node);
    return (!unPromised ||
        unPromised.kind === typescript_1.SyntaxKind.AnyKeyword ||
        unPromised.kind === typescript_1.SyntaxKind.UnknownKeyword ||
        (ts.isTypeLiteralNode(unPromised) && unPromised.members.length === 0));
}
exports.isAnyUnknown = isAnyUnknown;
//# sourceMappingURL=utils.js.map