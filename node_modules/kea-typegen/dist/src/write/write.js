"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.writePaths = exports.writeTypeImports = void 0;
const ts = require("typescript");
const utils_1 = require("../utils");
const fs = require("fs");
const print_1 = require("../print/print");
const diff = require("diff");
const path = require("path");
const typescript_1 = require("typescript");
function addBackNewlines(oldText, newText) {
    const patch = diff.parsePatch(diff.createPatch('file', oldText, newText, '', ''));
    const hunks = patch[0].hunks;
    for (let i = 0; i < hunks.length; ++i) {
        let lineOffset = 0;
        const hunk = hunks[i];
        hunk.lines = hunk.lines.map((line) => {
            if (line === '-') {
                lineOffset++;
                return ' ';
            }
            return line;
        });
        hunk.newLines += lineOffset;
        for (let j = i + 1; j < hunks.length; ++j) {
            hunks[j].newStart += lineOffset;
        }
    }
    return diff.applyPatch(oldText, patch);
}
function writeTypeImports(appOptions, program, filename, parsedLogics, allParsedLogics) {
    const { log } = appOptions;
    const sourceFile = program.getSourceFile(filename);
    const checker = program.getTypeChecker();
    const parsedLogicMapByNode = new Map();
    for (const parsedLogic of parsedLogics) {
        parsedLogicMapByNode.set(parsedLogic.node, parsedLogic);
    }
    let importLocation = path.relative(path.dirname(filename), parsedLogics[0].typeFileName).replace(/\.[tj]sx?$/, '');
    if (!importLocation.startsWith('.')) {
        importLocation = `./${importLocation}`;
    }
    const createImportDeclaration = () => typescript_1.factory.createImportDeclaration(undefined, undefined, typescript_1.factory.createImportClause(true, undefined, typescript_1.factory.createNamedImports(allParsedLogics.map((l) => typescript_1.factory.createImportSpecifier(undefined, undefined, typescript_1.factory.createIdentifier(l.logicTypeName))))), typescript_1.factory.createStringLiteral(importLocation));
    const transformer = (context) => {
        return (rootNode) => {
            function visit(node) {
                node = ts.visitEachChild(node, visit, context);
                if (ts.isCallExpression(node) &&
                    (0, utils_1.isKeaCall)(node.expression, checker) &&
                    parsedLogicMapByNode.has(node.expression)) {
                    const { logicTypeName, typeReferencesInLogicInput } = parsedLogicMapByNode.get(node.expression);
                    return typescript_1.factory.createCallExpression(node.expression, [
                        typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createIdentifier(logicTypeName), typeReferencesInLogicInput.size > 0
                            ? [...typeReferencesInLogicInput.values()]
                                .sort()
                                .map((type) => typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createIdentifier(type), undefined))
                            : undefined),
                    ], node.arguments);
                }
                if (ts.isSourceFile(node)) {
                    let foundImport = false;
                    let changedImport = false;
                    let newStatements = sourceFile.statements.map((node) => {
                        if (ts.isImportDeclaration(node)) {
                            const moduleFile = node.moduleSpecifier.getText().split(/['"]/).join('');
                            if (path.resolve(path.dirname(filename), moduleFile) ===
                                path.resolve(path.dirname(filename), importLocation)) {
                                foundImport = true;
                                const bindings = node.importClause.namedBindings;
                                if (ts.isNamedImports(bindings)) {
                                    const oldString = bindings.elements
                                        .map((e) => e.getText())
                                        .sort()
                                        .join(',');
                                    const newString = parsedLogics
                                        .map((l) => l.logicTypeName)
                                        .sort()
                                        .join(',');
                                    if (oldString !== newString) {
                                        changedImport = true;
                                        return createImportDeclaration();
                                    }
                                }
                            }
                        }
                        return node;
                    });
                    if (!foundImport) {
                        newStatements = [
                            ...sourceFile.statements.filter((node) => ts.isImportDeclaration(node)),
                            createImportDeclaration(),
                            ...sourceFile.statements.filter((node) => !ts.isImportDeclaration(node)),
                        ];
                    }
                    if (!foundImport || changedImport) {
                        return ts.updateSourceFileNode(sourceFile, newStatements);
                    }
                }
                return node;
            }
            return ts.visitNode(rootNode, visit);
        };
    };
    writeFile(sourceFile, transformer, filename);
    log(`ðŸ”¥ Import added: ${path.relative(process.cwd(), filename)}`);
}
exports.writeTypeImports = writeTypeImports;
function writePaths(appOptions, program, filename, parsedLogics) {
    const { log } = appOptions;
    const sourceFile = program.getSourceFile(filename);
    const checker = program.getTypeChecker();
    const parsedLogicMapByNode = new Map();
    for (const parsedLogic of parsedLogics) {
        parsedLogicMapByNode.set(parsedLogic.node, parsedLogic);
    }
    const transformer = (context) => {
        return (rootNode) => {
            function visit(node) {
                node = ts.visitEachChild(node, visit, context);
                if (ts.isCallExpression(node) &&
                    (0, utils_1.isKeaCall)(node.expression, checker) &&
                    parsedLogicMapByNode.has(node.expression)) {
                    const { path, hasKeyInLogic } = parsedLogicMapByNode.get(node.expression);
                    return typescript_1.factory.createCallExpression(node.expression, node.typeArguments, node.arguments.map((argument, i) => i === 0 && ts.isObjectLiteralExpression(argument)
                        ? typescript_1.factory.createObjectLiteralExpression([
                            hasKeyInLogic
                                ? typescript_1.factory.createPropertyAssignment(typescript_1.factory.createIdentifier('path'), typescript_1.factory.createArrowFunction(undefined, undefined, [
                                    typescript_1.factory.createParameterDeclaration(undefined, undefined, undefined, typescript_1.factory.createIdentifier('key'), undefined, undefined, undefined),
                                ], undefined, typescript_1.factory.createToken(typescript_1.SyntaxKind.EqualsGreaterThanToken), typescript_1.factory.createArrayLiteralExpression([
                                    ...path.map((str) => typescript_1.factory.createStringLiteral(str)),
                                    typescript_1.factory.createIdentifier('key'),
                                ], false)))
                                : typescript_1.factory.createPropertyAssignment(typescript_1.factory.createIdentifier('path'), typescript_1.factory.createArrayLiteralExpression(path.map((str) => typescript_1.factory.createStringLiteral(str)), false)),
                            ...argument.properties,
                        ], true)
                        : argument));
                }
                return node;
            }
            return ts.visitNode(rootNode, visit);
        };
    };
    writeFile(sourceFile, transformer, filename);
    log(`ðŸ”¥ Path added: ${path.relative(process.cwd(), filename)}`);
}
exports.writePaths = writePaths;
function writeFile(sourceFile, transformer, filename) {
    const printer = ts.createPrinter();
    const result = ts.transform(sourceFile, [transformer]);
    const transformedSourceFile = result.transformed[0];
    const newContent = printer.printFile(transformedSourceFile);
    const newText = (0, print_1.runThroughPrettier)(newContent, filename);
    result.dispose();
    const oldText = sourceFile.getText();
    const newestText = addBackNewlines(oldText, newText);
    fs.writeFileSync(filename, newestText);
}
//# sourceMappingURL=write.js.map