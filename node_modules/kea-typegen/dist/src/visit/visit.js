"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.visitKeaCalls = exports.visitResetContext = exports.visitProgram = void 0;
const ts = require("typescript");
const path = require("path");
const utils_1 = require("../utils");
const visitActions_1 = require("./visitActions");
const visitReducers_1 = require("./visitReducers");
const visitSelectors_1 = require("./visitSelectors");
const visitLoaders_1 = require("./visitLoaders");
const visitConnect_1 = require("./visitConnect");
const visitWindowValues_1 = require("./visitWindowValues");
const visitProps_1 = require("./visitProps");
const visitKey_1 = require("./visitKey");
const visitPath_1 = require("./visitPath");
const visitListeners_1 = require("./visitListeners");
const visitConstants_1 = require("./visitConstants");
const visitEvents_1 = require("./visitEvents");
const visitDefaults_1 = require("./visitDefaults");
const visitSharedListeners_1 = require("./visitSharedListeners");
const ts_clone_node_1 = require("@wessberg/ts-clone-node");
const visitFunctions = {
    actions: visitActions_1.visitActions,
    connect: visitConnect_1.visitConnect,
    constants: visitConstants_1.visitConstants,
    defaults: visitDefaults_1.visitDefaults,
    events: visitEvents_1.visitEvents,
    key: visitKey_1.visitKey,
    listeners: visitListeners_1.visitListeners,
    loaders: visitLoaders_1.visitLoaders,
    path: visitPath_1.visitPath,
    props: visitProps_1.visitProps,
    reducers: visitReducers_1.visitReducers,
    selectors: visitSelectors_1.visitSelectors,
    sharedListeners: visitSharedListeners_1.visitSharedListeners,
    windowValues: visitWindowValues_1.visitWindowValues,
};
function visitProgram(program, appOptions) {
    const checker = program.getTypeChecker();
    const parsedLogics = [];
    const pluginModules = [];
    for (const sourceFile of program.getSourceFiles()) {
        if (!sourceFile.isDeclarationFile && !sourceFile.fileName.endsWith('Type.ts')) {
            ts.forEachChild(sourceFile, visitResetContext(checker, pluginModules));
        }
    }
    for (const sourceFile of program.getSourceFiles()) {
        if (!sourceFile.isDeclarationFile && !sourceFile.fileName.endsWith('Type.ts')) {
            if (appOptions === null || appOptions === void 0 ? void 0 : appOptions.verbose) {
                appOptions.log(`ðŸ‘€ Visiting: ${path.relative(process.cwd(), sourceFile.fileName)}`);
            }
            ts.forEachChild(sourceFile, visitKeaCalls(checker, parsedLogics, sourceFile, appOptions, pluginModules));
        }
    }
    return parsedLogics;
}
exports.visitProgram = visitProgram;
function visitResetContext(checker, pluginModules) {
    return function visit(node) {
        var _a;
        if (!ts.isIdentifier(node) ||
            !node.parent ||
            !ts.isCallExpression(node.parent) ||
            node.getText() !== 'resetContext') {
            ts.forEachChild(node, visit);
            return;
        }
        const callArgument = (_a = node.parent.arguments) === null || _a === void 0 ? void 0 : _a[0];
        if (ts.isObjectLiteralExpression(callArgument)) {
            for (const prop of callArgument.properties) {
                if (ts.isPropertyAssignment(prop) && prop.name.getText() === 'plugins') {
                    if (ts.isArrayLiteralExpression(prop.initializer)) {
                        for (const plugin of prop.initializer.elements) {
                            const identifier = ts.isCallExpression(plugin) ? plugin.expression : plugin;
                            const pluginName = identifier.getText();
                            const symbol = checker.getSymbolAtLocation(identifier);
                            if (symbol && !pluginModules.find(({ name }) => name === pluginName)) {
                                for (let declaration of symbol.getDeclarations()) {
                                    let decNode = declaration;
                                    while (decNode) {
                                        if (ts.isImportDeclaration(decNode)) {
                                            const filename = (0, utils_1.getFilenameForImportDeclaration)(checker, decNode);
                                            if (!filename) {
                                                break;
                                            }
                                            const folder = path.dirname(filename);
                                            for (const filename of ['typegen.js', 'typegen.ts']) {
                                                const typegenFile = path.resolve(folder, filename);
                                                try {
                                                    let typegenModule = require(typegenFile);
                                                    if (typegenModule && typegenModule.default) {
                                                        typegenModule = typegenModule.default;
                                                    }
                                                    if (typeof (typegenModule === null || typegenModule === void 0 ? void 0 : typegenModule.visitKeaProperty) !== 'undefined') {
                                                        pluginModules.push({
                                                            name: pluginName,
                                                            file: typegenFile,
                                                            visitKeaProperty: typegenModule.visitKeaProperty,
                                                        });
                                                        break;
                                                    }
                                                }
                                                catch (error) {
                                                    if (error.code !== 'MODULE_NOT_FOUND') {
                                                        console.error(error);
                                                    }
                                                }
                                            }
                                        }
                                        decNode = decNode.parent;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    };
}
exports.visitResetContext = visitResetContext;
function visitKeaCalls(checker, parsedLogics, sourceFile, appOptions, pluginModules) {
    return function visit(node) {
        var _a, _b, _c, _d;
        if (!(0, utils_1.isKeaCall)(node, checker)) {
            ts.forEachChild(node, visit);
            return;
        }
        let logicName = 'logic';
        if (ts.isCallExpression(node.parent) && ts.isVariableDeclaration(node.parent.parent)) {
            logicName = node.parent.parent.name.getText();
        }
        const logicTypeName = `${logicName}Type`;
        let logicTypeArguments = [];
        let logicTypeImported = false;
        const keaTypeArguments = ts.isCallExpression(node.parent) ? node.parent.typeArguments : [];
        const keaTypeArgument = keaTypeArguments === null || keaTypeArguments === void 0 ? void 0 : keaTypeArguments[0];
        const pathString = (0, utils_1.getLogicPathString)(appOptions, sourceFile.fileName);
        let typeFileName = sourceFile.fileName.replace(/\.[tj]sx?$/, 'Type.ts');
        if (((_a = keaTypeArgument === null || keaTypeArgument === void 0 ? void 0 : keaTypeArgument.typeName) === null || _a === void 0 ? void 0 : _a.escapedText) === logicTypeName) {
            if (keaTypeArgument.typeArguments && keaTypeArgument.typeArguments.length > 0) {
                logicTypeArguments = keaTypeArgument.typeArguments.map((a) => a.getFullText().trim());
            }
            const symbol = checker.getSymbolAtLocation(keaTypeArgument.typeName);
            if (symbol) {
                const declaration = (_b = symbol.getDeclarations()) === null || _b === void 0 ? void 0 : _b[0];
                if (declaration && ts.isImportSpecifier(declaration)) {
                    const filename = (0, utils_1.getFilenameForImportSpecifier)(declaration, checker);
                    logicTypeImported = filename === typeFileName;
                }
            }
        }
        if ((appOptions === null || appOptions === void 0 ? void 0 : appOptions.rootPath) && (appOptions === null || appOptions === void 0 ? void 0 : appOptions.typesPath)) {
            const relativePathFromRoot = path.relative(appOptions.rootPath, typeFileName);
            typeFileName = path.resolve(appOptions.typesPath, relativePathFromRoot);
        }
        const parsedLogic = {
            checker,
            node,
            logicName,
            logicTypeImported,
            logicTypeName,
            logicTypeArguments,
            fileName: sourceFile.fileName,
            typeFileName,
            actions: [],
            reducers: [],
            selectors: [],
            constants: [],
            listeners: [],
            sharedListeners: [],
            events: {},
            extraActions: {},
            keyType: undefined,
            propsType: undefined,
            path: pathString.split('.'),
            pathString: pathString,
            hasKeyInLogic: false,
            hasPathInLogic: false,
            typeReferencesToImportFromFiles: {},
            typeReferencesInLogicInput: new Set(),
            extraInput: {},
        };
        const input = node.parent.arguments[0];
        for (const inputProperty of input.properties) {
            if (!ts.isPropertyAssignment(inputProperty)) {
                continue;
            }
            const symbol = checker.getSymbolAtLocation(inputProperty.name);
            if (!symbol) {
                continue;
            }
            const name = symbol.getName();
            if (name === 'path') {
                parsedLogic.hasPathInLogic = true;
            }
            if (name === 'key') {
                parsedLogic.hasKeyInLogic = true;
            }
            let type = checker.getTypeOfSymbolAtLocation(symbol, symbol.valueDeclaration);
            let typeNode = type ? checker.typeToTypeNode(type, undefined, undefined) : null;
            if (typeNode && ts.isFunctionTypeNode(typeNode)) {
                type = type.getCallSignatures()[0].getReturnType();
                typeNode = type ? checker.typeToTypeNode(type, undefined, undefined) : null;
            }
            (_c = visitFunctions[name]) === null || _c === void 0 ? void 0 : _c.call(visitFunctions, type, inputProperty, parsedLogic);
            const visitKeaPropertyArguments = {
                name,
                appOptions,
                type,
                typeNode,
                parsedLogic,
                node: inputProperty.initializer,
                checker,
                gatherImports: (input) => (0, utils_1.gatherImports)(input, checker, parsedLogic),
                cloneNode: ts_clone_node_1.cloneNode,
                getTypeNodeForNode: (node) => (0, utils_1.getTypeNodeForNode)(node, checker),
                prepareForPrint: (node) => {
                    (0, utils_1.gatherImports)(node, checker, parsedLogic);
                    return (0, ts_clone_node_1.cloneNode)(node);
                },
            };
            for (const pluginModule of Object.values(pluginModules)) {
                try {
                    (_d = pluginModule.visitKeaProperty) === null || _d === void 0 ? void 0 : _d.call(pluginModule, visitKeaPropertyArguments);
                }
                catch (e) {
                    console.error(`!! Problem running "visitKeaProperty" on plugin "${pluginModule.name}" (${pluginModule.file})`);
                    console.error(e);
                }
            }
        }
        parsedLogics.push(parsedLogic);
    };
}
exports.visitKeaCalls = visitKeaCalls;
//# sourceMappingURL=visit.js.map