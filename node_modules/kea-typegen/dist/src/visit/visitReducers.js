"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.visitReducers = void 0;
const ts = require("typescript");
const utils_1 = require("../utils");
const ts_clone_node_1 = require("@wessberg/ts-clone-node");
function visitReducers(type, inputProperty, parsedLogic) {
    const { checker } = parsedLogic;
    for (const property of type.getProperties()) {
        const name = property.getName();
        const value = property.valueDeclaration.initializer;
        if (value) {
            let extraActions = {};
            let typeNode;
            let reducerOptions;
            if (ts.isArrayLiteralExpression(value)) {
                let defaultValue = value.elements[0];
                typeNode = (0, utils_1.getAndGatherTypeNodeForDefaultValue)(defaultValue, checker, parsedLogic);
                if (ts.isFunctionTypeNode(typeNode)) {
                    typeNode = typeNode.type;
                }
                const actionObjects = value.elements[value.elements.length - 1];
                extraActions = (0, utils_1.extractImportedActions)(actionObjects, checker, parsedLogic);
                if (value.elements.length > 2) {
                    const options = value.elements[value.elements.length - 2];
                    if (ts.isObjectLiteralExpression(options)) {
                        reducerOptions = (0, ts_clone_node_1.cloneNode)(checker.typeToTypeNode(checker.getTypeAtLocation(options), undefined, undefined));
                    }
                }
            }
            else if (ts.isObjectLiteralExpression(value)) {
                typeNode = ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);
            }
            parsedLogic.reducers.push({ name, typeNode, reducerOptions });
            if (Object.keys(extraActions).length > 0) {
                Object.assign(parsedLogic.extraActions, extraActions);
            }
        }
    }
}
exports.visitReducers = visitReducers;
//# sourceMappingURL=visitReducers.js.map