"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.visitLoaders = void 0;
const typescript_1 = require("typescript");
const utils_1 = require("../utils");
const typescript_2 = require("typescript");
function visitLoaders(type, inputProperty, parsedLogic) {
    var _a;
    const { checker } = parsedLogic;
    for (const property of type.getProperties()) {
        const loaderName = property.getName();
        const value = property.valueDeclaration.initializer;
        let defaultValue;
        let objectLiteral;
        if ((0, typescript_1.isArrayLiteralExpression)(value)) {
            defaultValue = value.elements[0];
            objectLiteral = value.elements[1];
        }
        else if ((0, typescript_1.isObjectLiteralExpression)(value)) {
            defaultValue = (_a = value.properties.find((property) => { var _a; return ((_a = checker.getSymbolAtLocation(property.name)) === null || _a === void 0 ? void 0 : _a.getName()) === '__default'; })) === null || _a === void 0 ? void 0 : _a.initializer;
            objectLiteral = value;
        }
        const defaultValueTypeNode = (0, utils_1.getAndGatherTypeNodeForDefaultValue)(defaultValue, checker, parsedLogic);
        (0, utils_1.gatherImports)(defaultValueTypeNode, checker, parsedLogic);
        parsedLogic.reducers.push({ name: loaderName, typeNode: defaultValueTypeNode });
        parsedLogic.reducers.push({
            name: `${loaderName}Loading`,
            typeNode: typescript_1.factory.createKeywordTypeNode(typescript_1.SyntaxKind.BooleanKeyword),
        });
        if (objectLiteral) {
            ;
            (objectLiteral.properties || []).forEach((property) => {
                var _a, _b, _c, _d, _e;
                const loaderActionName = (_a = checker.getSymbolAtLocation(property.name)) === null || _a === void 0 ? void 0 : _a.getName();
                if (loaderActionName === '__default') {
                    return;
                }
                const func = property.initializer;
                if (!(0, typescript_1.isFunctionLike)(func)) {
                    return;
                }
                const param = func.parameters ? func.parameters[0] : null;
                const parameters = param ? [(0, utils_1.getParameterDeclaration)(param)] : [];
                if (!parsedLogic.actions.find(({ name }) => name === `${loaderActionName}`)) {
                    const returnTypeNode = (param === null || param === void 0 ? void 0 : param.type) || typescript_1.factory.createKeywordTypeNode(typescript_1.SyntaxKind.AnyKeyword);
                    (0, utils_1.gatherImports)(param, checker, parsedLogic);
                    parsedLogic.actions.push({ name: `${loaderActionName}`, parameters, returnTypeNode });
                }
                if (!parsedLogic.actions.find(({ name }) => name === `${loaderActionName}Success`)) {
                    let returnTypeNode;
                    if (func) {
                        const funcType = checker.getTypeAtLocation(func);
                        const signature = funcType === null || funcType === void 0 ? void 0 : funcType.getCallSignatures()[0];
                        const sigReturnType = signature === null || signature === void 0 ? void 0 : signature.getReturnType();
                        if (sigReturnType) {
                            const resolvedReturnType = checker.typeToTypeNode(sigReturnType, undefined, typescript_2.NodeBuilderFlags.NoTruncation);
                            if (!(0, utils_1.isAnyUnknown)((0, utils_1.unPromisify)(resolvedReturnType))) {
                                returnTypeNode = resolvedReturnType;
                            }
                        }
                        if (!returnTypeNode && !(0, utils_1.isAnyUnknown)(func.type)) {
                            returnTypeNode = func.type;
                        }
                    }
                    if (!returnTypeNode) {
                        returnTypeNode = defaultValueTypeNode || typescript_1.factory.createKeywordTypeNode(typescript_1.SyntaxKind.AnyKeyword);
                    }
                    if ((0, typescript_1.isTypeReferenceNode)(returnTypeNode) &&
                        ((_b = returnTypeNode.typeName) === null || _b === void 0 ? void 0 : _b.escapedText) === 'Promise') {
                        returnTypeNode = (_c = returnTypeNode.typeArguments) === null || _c === void 0 ? void 0 : _c[0];
                    }
                    (0, utils_1.gatherImports)(returnTypeNode, checker, parsedLogic);
                    const successParameters = [
                        typescript_1.factory.createParameterDeclaration(undefined, undefined, undefined, typescript_1.factory.createIdentifier(loaderName), undefined, returnTypeNode, undefined),
                        typescript_1.factory.createParameterDeclaration(undefined, undefined, undefined, typescript_1.factory.createIdentifier('payload'), typescript_1.factory.createToken(typescript_1.SyntaxKind.QuestionToken), (_d = parsedLogic.actions.find((a) => a.name === loaderActionName)) === null || _d === void 0 ? void 0 : _d.returnTypeNode, undefined),
                    ];
                    const successReturnTypeNode = typescript_1.factory.createTypeLiteralNode([
                        typescript_1.factory.createPropertySignature(undefined, typescript_1.factory.createIdentifier(loaderName), undefined, returnTypeNode),
                        typescript_1.factory.createPropertySignature(undefined, typescript_1.factory.createIdentifier('payload'), typescript_1.factory.createToken(typescript_1.SyntaxKind.QuestionToken), (_e = parsedLogic.actions.find((a) => a.name === loaderActionName)) === null || _e === void 0 ? void 0 : _e.returnTypeNode),
                    ]);
                    parsedLogic.actions.push({
                        name: `${loaderActionName}Success`,
                        parameters: successParameters,
                        returnTypeNode: successReturnTypeNode,
                    });
                }
                if (!parsedLogic.actions.find(({ name }) => name === `${loaderActionName}Failure`)) {
                    const failureParameters = [
                        typescript_1.factory.createParameterDeclaration(undefined, undefined, undefined, typescript_1.factory.createIdentifier('error'), undefined, typescript_1.factory.createKeywordTypeNode(typescript_1.SyntaxKind.StringKeyword), undefined),
                        typescript_1.factory.createParameterDeclaration(undefined, undefined, undefined, typescript_1.factory.createIdentifier('errorObject'), typescript_1.factory.createToken(typescript_1.SyntaxKind.QuestionToken), typescript_1.factory.createKeywordTypeNode(typescript_1.SyntaxKind.AnyKeyword), undefined),
                    ];
                    const failureReturnTypeNode = typescript_1.factory.createTypeLiteralNode([
                        typescript_1.factory.createPropertySignature(undefined, typescript_1.factory.createIdentifier('error'), undefined, typescript_1.factory.createKeywordTypeNode(typescript_1.SyntaxKind.StringKeyword)),
                        typescript_1.factory.createPropertySignature(undefined, typescript_1.factory.createIdentifier('errorObject'), typescript_1.factory.createToken(typescript_1.SyntaxKind.QuestionToken), typescript_1.factory.createKeywordTypeNode(typescript_1.SyntaxKind.AnyKeyword)),
                    ]);
                    parsedLogic.actions.push({
                        name: `${loaderActionName}Failure`,
                        parameters: failureParameters,
                        returnTypeNode: failureReturnTypeNode,
                    });
                }
            });
        }
    }
}
exports.visitLoaders = visitLoaders;
//# sourceMappingURL=visitLoaders.js.map