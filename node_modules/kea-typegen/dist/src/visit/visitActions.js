"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.visitActions = void 0;
const typescript_1 = require("typescript");
const typescript_2 = require("typescript");
const ts_clone_node_1 = require("@wessberg/ts-clone-node");
const utils_1 = require("../utils");
function visitActions(type, inputProperty, parsedLogic) {
    const { checker } = parsedLogic;
    const properties = checker.getPropertiesOfType(type);
    for (const property of properties) {
        const type = checker.getTypeOfSymbolAtLocation(property, property.valueDeclaration);
        const name = property.getName();
        let returnTypeNode;
        let parameters;
        if (!(0, typescript_1.isPropertyAssignment)(property.valueDeclaration)) {
            continue;
        }
        const { initializer } = property.valueDeclaration;
        if ((0, typescript_1.isFunctionLike)(initializer)) {
            parameters = initializer.parameters.map((param) => {
                if (param.type) {
                    (0, utils_1.gatherImports)(param.type, checker, parsedLogic);
                }
                return typescript_1.factory.createParameterDeclaration(undefined, undefined, undefined, typescript_1.factory.createIdentifier(param.name.getText()), param.initializer || param.questionToken
                    ? typescript_1.factory.createToken(typescript_1.SyntaxKind.QuestionToken)
                    : undefined, param.type ? (0, ts_clone_node_1.cloneNode)(param.type) : typescript_1.factory.createKeywordTypeNode(typescript_1.SyntaxKind.AnyKeyword), undefined);
            });
            returnTypeNode = initializer.type;
            if (!returnTypeNode) {
                const signature = type.getCallSignatures()[0];
                const sigReturnType = signature.getReturnType();
                const sigReturnTypeNode = checker.typeToTypeNode(sigReturnType, undefined, typescript_2.NodeBuilderFlags.NoTruncation);
                returnTypeNode = sigReturnTypeNode;
            }
            (0, utils_1.gatherImports)(returnTypeNode, checker, parsedLogic);
            returnTypeNode = (0, ts_clone_node_1.cloneNode)(returnTypeNode);
        }
        else {
            const typeNode = checker.typeToTypeNode(type, undefined, undefined);
            (0, utils_1.gatherImports)(typeNode, checker, parsedLogic);
            returnTypeNode = typescript_1.factory.createTypeLiteralNode([
                typescript_1.factory.createPropertySignature(undefined, typescript_1.factory.createIdentifier('value'), undefined, typeNode),
            ]);
        }
        parsedLogic.actions.push({ name, parameters, returnTypeNode });
    }
}
exports.visitActions = visitActions;
//# sourceMappingURL=visitActions.js.map