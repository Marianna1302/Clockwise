"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.visitSelectors = void 0;
const ts = require("typescript");
const typescript_1 = require("typescript");
const ts_clone_node_1 = require("@wessberg/ts-clone-node");
const utils_1 = require("../utils");
function visitSelectors(type, inputProperty, parsedLogic) {
    var _a;
    const { checker } = parsedLogic;
    for (const property of type.getProperties()) {
        const name = property.getName();
        const value = property.valueDeclaration.initializer;
        if (ts.isArrayLiteralExpression(value) && value.elements.length > 1) {
            const inputFunction = value.elements[0];
            const inputFunctionTypeNode = checker.getTypeAtLocation(inputFunction);
            const selectorInputFunctionType = (_a = inputFunctionTypeNode.getCallSignatures()[0]) === null || _a === void 0 ? void 0 : _a.getReturnType();
            const selectorInputTypeNode = selectorInputFunctionType
                ? checker.typeToTypeNode(selectorInputFunctionType, inputFunction, typescript_1.NodeBuilderFlags.NoTruncation)
                : null;
            let functionNames = [];
            if (ts.isArrayLiteralExpression(inputFunction.body)) {
                functionNames = inputFunction.body.elements.map((element) => {
                    if (ts.isPropertyAccessExpression(element)) {
                        return element.name.getText();
                    }
                    else {
                        return null;
                    }
                });
            }
            let functionTypes = [];
            if (selectorInputTypeNode && ts.isTupleTypeNode(selectorInputTypeNode)) {
                let takenNames = {};
                functionTypes = (selectorInputTypeNode.elements || ts.factory.createNodeArray([]))
                    .filter((e) => ts.isTypeNode(e))
                    .map((selectorTypeNode, index) => {
                    let name = functionNames[index] || 'arg';
                    takenNames[name] = (takenNames[name] || 0) + 1;
                    if (takenNames[name] > 1) {
                        name = `${name}${takenNames[name]}`;
                    }
                    if (ts.isFunctionTypeNode(selectorTypeNode)) {
                        (0, utils_1.gatherImports)(selectorTypeNode.type, checker, parsedLogic);
                    }
                    return {
                        name,
                        type: ts.isFunctionTypeNode(selectorTypeNode)
                            ? (0, ts_clone_node_1.cloneNode)(selectorTypeNode.type)
                            : ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword),
                    };
                });
            }
            const computedFunction = value.elements[1];
            if (ts.isFunctionLike(computedFunction)) {
                const type = checker.getReturnTypeOfSignature(checker.getSignatureFromDeclaration(computedFunction));
                let typeNode;
                if (computedFunction.type) {
                    (0, utils_1.gatherImports)(computedFunction.type, checker, parsedLogic);
                    typeNode = (0, ts_clone_node_1.cloneNode)(computedFunction.type);
                }
                else if (type) {
                    typeNode = checker.typeToTypeNode(type, undefined, typescript_1.NodeBuilderFlags.NoTruncation);
                    (0, utils_1.gatherImports)(typeNode, checker, parsedLogic);
                }
                else {
                    typeNode = ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);
                }
                parsedLogic.selectors.push({
                    name,
                    typeNode,
                    functionTypes,
                });
            }
        }
    }
}
exports.visitSelectors = visitSelectors;
//# sourceMappingURL=visitSelectors.js.map