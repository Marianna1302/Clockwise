"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.printLogicType = exports.getLogicTypeArguments = exports.parsedLogicToTypeString = exports.nodeToString = exports.printToFiles = exports.runThroughPrettier = void 0;
const typescript_1 = require("typescript");
const fs = require("fs");
const path = require("path");
const prettier = require("prettier");
const printActions_1 = require("./printActions");
const printReducers_1 = require("./printReducers");
const printReducer_1 = require("./printReducer");
const printSelector_1 = require("./printSelector");
const printSelectors_1 = require("./printSelectors");
const printValues_1 = require("./printValues");
const printInternalSelectorTypes_1 = require("./printInternalSelectorTypes");
const printActionKeys_1 = require("./printActionKeys");
const printActionTypes_1 = require("./printActionTypes");
const printInternalReducerActions_1 = require("./printInternalReducerActions");
const printActionCreators_1 = require("./printActionCreators");
const printProps_1 = require("./printProps");
const printKey_1 = require("./printKey");
const printDefaults_1 = require("./printDefaults");
const printConstants_1 = require("./printConstants");
const printReducerOptions_1 = require("./printReducerOptions");
const printEvents_1 = require("./printEvents");
const printSharedListeners_1 = require("./printSharedListeners");
const printListeners_1 = require("./printListeners");
const write_1 = require("../write/write");
const printInternalExtraInput_1 = require("./printInternalExtraInput");
function runThroughPrettier(sourceText, filePath) {
    const options = prettier.resolveConfig.sync(filePath);
    if (options) {
        try {
            return prettier.format(sourceText, Object.assign(Object.assign({}, options), { filepath: filePath }));
        }
        catch (e) {
            console.error(`!! Prettier: Error formatting "${filePath}"`);
            console.error(e.message);
            return sourceText;
        }
    }
    else {
        return sourceText;
    }
}
exports.runThroughPrettier = runThroughPrettier;
function printToFiles(program, appOptions, parsedLogics) {
    const { log } = appOptions;
    const groupedByFile = {};
    for (const parsedLogic of parsedLogics) {
        if (!groupedByFile[parsedLogic.fileName]) {
            groupedByFile[parsedLogic.fileName] = [];
        }
        groupedByFile[parsedLogic.fileName].push(parsedLogic);
        printLogicType(parsedLogic, appOptions);
    }
    const defaultGlobalTypePaths = appOptions.importGlobalTypes
        ? []
        : (program.getCompilerOptions().types || []).map((type) => path.join(appOptions.packageJsonPath ? path.dirname(appOptions.packageJsonPath) : appOptions.rootPath, 'node_modules', '@types', type) + path.sep);
    const ignoredImportPaths = (appOptions.ignoreImportPaths || []).map((importPath) => path.resolve(appOptions.rootPath, importPath));
    const doNotImportFromPaths = [...defaultGlobalTypePaths, ...ignoredImportPaths];
    const shouldIgnore = (absolutePath) => !!doNotImportFromPaths.find((badPath) => absolutePath.startsWith(badPath));
    let writtenFiles = 0;
    let filesToWrite = 0;
    let filesToModify = 0;
    Object.entries(groupedByFile).forEach(([fileName, parsedLogics]) => {
        var _a;
        const typeFileName = parsedLogics[0].typeFileName;
        const logicStrings = [];
        for (const parsedLogic of parsedLogics) {
            const logicTypeStirng = runThroughPrettier(nodeToString(parsedLogic.interfaceDeclaration), typeFileName);
            logicStrings.push(logicTypeStirng);
        }
        const output = logicStrings.join('\n\n');
        const requiredKeys = ['Logic'];
        if (parsedLogics.find((l) => l.sharedListeners.length > 0)) {
            requiredKeys.push('BreakPointFunction');
        }
        const otherimports = Object.entries(parsedLogics[0].typeReferencesToImportFromFiles)
            .filter(([_, list]) => list.size > 0)
            .map(([file, list]) => {
            let relativePath = path.relative(path.dirname(parsedLogics[0].typeFileName), file);
            relativePath = relativePath.replace(/\.tsx?$/, '');
            if (!relativePath.startsWith('.')) {
                relativePath = `./${relativePath}`;
            }
            return {
                list: [...list].sort(),
                fullPath: file,
                relativePath,
            };
        })
            .filter(({ fullPath }) => !shouldIgnore(fullPath))
            .map(({ list, relativePath }) => `import { ${list.join(', ')} } from '${relativePath}'`)
            .join('\n');
        const finalOutput = [
            `// Generated by kea-typegen on ${new Date().toUTCString()}. DO NOT EDIT THIS FILE MANUALLY.`,
            `import { ${requiredKeys.join(', ')} } from 'kea'`,
            otherimports,
            output,
        ]
            .filter((a) => !!a)
            .join('\n\n');
        let existingOutput;
        try {
            existingOutput = (_a = fs.readFileSync(typeFileName)) === null || _a === void 0 ? void 0 : _a.toString();
        }
        catch (error) { }
        if (!existingOutput ||
            (existingOutput &&
                existingOutput.split('\n').slice(1).join('\n') !== finalOutput.split('\n').slice(1).join('\n'))) {
            filesToWrite += 1;
            if (appOptions.write) {
                fs.mkdirSync(path.dirname(typeFileName), { recursive: true });
                fs.writeFileSync(typeFileName, finalOutput);
                writtenFiles += 1;
                log(`🔥 Writing: ${path.relative(process.cwd(), typeFileName)}`);
            }
            else {
                log(`❌ Will not write: ${path.relative(process.cwd(), typeFileName)}`);
            }
        }
        else {
            if (appOptions.verbose) {
                log(`🤷 Unchanged: ${path.relative(process.cwd(), typeFileName)}`);
            }
        }
        const parsedLogicNeedsTypeImport = (pl) => (pl.logicTypeImported === false ||
            pl.logicTypeArguments.join(', ') !== [...pl.typeReferencesInLogicInput].sort().join(', ')) &&
            pl.fileName.match(/\.tsx?$/);
        const logicsNeedingImports = parsedLogics.filter(parsedLogicNeedsTypeImport);
        if (logicsNeedingImports.length > 0) {
            if (appOptions.write && !appOptions.noImport) {
                (0, write_1.writeTypeImports)(appOptions, program, fileName, logicsNeedingImports, parsedLogics);
                filesToModify += logicsNeedingImports.length;
            }
            else {
                log(`❌ Will not write ${logicsNeedingImports.length} logic type import${logicsNeedingImports.length === 1 ? '' : 's'}`);
            }
        }
        const parsedLogicNeedsPath = appOptions.writePaths ? (pl) => !pl.hasPathInLogic : () => false;
        const logicsNeedingPaths = parsedLogics.filter(parsedLogicNeedsPath);
        if (logicsNeedingPaths.length > 0) {
            if (appOptions.write && !appOptions.noImport) {
                (0, write_1.writePaths)(appOptions, program, fileName, logicsNeedingPaths);
                filesToModify += logicsNeedingPaths.length;
            }
            else {
                log(`❌ Will not write ${logicsNeedingPaths.length} logic path${logicsNeedingPaths.length === 1 ? '' : 's'}`);
            }
        }
    });
    if (writtenFiles === 0 && filesToModify === 0) {
        if (appOptions.write) {
            log(`💚 ${parsedLogics.length} logic type${parsedLogics.length === 1 ? '' : 's'} up to date!`);
            log('');
        }
        else if (filesToWrite > 0 || filesToModify > 0) {
            log(`🚨 Run "kea-typegen write" to save ${filesToWrite + filesToModify} file${filesToWrite === 1 ? '' : 's'} to disk`);
        }
    }
    return { filesToWrite, writtenFiles, filesToModify };
}
exports.printToFiles = printToFiles;
function nodeToString(node) {
    const printer = (0, typescript_1.createPrinter)({ newLine: typescript_1.NewLineKind.LineFeed });
    const sourceFile = (0, typescript_1.createSourceFile)('logic.ts', '', typescript_1.ScriptTarget.Latest, false, typescript_1.ScriptKind.TS);
    return printer.printNode(typescript_1.EmitHint.Unspecified, node, sourceFile);
}
exports.nodeToString = nodeToString;
function parsedLogicToTypeString(parsedLogic, appOptions) {
    printLogicType(parsedLogic, appOptions);
    return nodeToString(parsedLogic.interfaceDeclaration);
}
exports.parsedLogicToTypeString = parsedLogicToTypeString;
function getLogicTypeArguments(parsedLogic) {
    return [...parsedLogic.typeReferencesInLogicInput]
        .sort()
        .map((text) => typescript_1.factory.createTypeParameterDeclaration(typescript_1.factory.createIdentifier(text), undefined));
}
exports.getLogicTypeArguments = getLogicTypeArguments;
function printLogicType(parsedLogic, appOptions) {
    const printProperty = (name, typeNode) => typescript_1.factory.createPropertySignature(undefined, typescript_1.factory.createIdentifier(name), undefined, typeNode);
    const addSelectorTypeHelp = parsedLogic.selectors.filter((s) => s.functionTypes.length > 0).length > 0;
    const logicProperties = [
        printProperty('actionCreators', (0, printActionCreators_1.printActionCreators)(parsedLogic, appOptions)),
        printProperty('actionKeys', (0, printActionKeys_1.printActionKeys)(parsedLogic, appOptions)),
        printProperty('actionTypes', (0, printActionTypes_1.printActionTypes)(parsedLogic, appOptions)),
        printProperty('actions', (0, printActions_1.printActions)(parsedLogic, appOptions)),
        printProperty('constants', (0, printConstants_1.printConstants)(parsedLogic)),
        printProperty('defaults', (0, printDefaults_1.printDefaults)(parsedLogic)),
        printProperty('events', (0, printEvents_1.printEvents)(parsedLogic)),
        printProperty('key', (0, printKey_1.printKey)(parsedLogic)),
        printProperty('listeners', (0, printListeners_1.printListeners)(parsedLogic)),
        printProperty('path', typescript_1.factory.createTupleTypeNode(parsedLogic.path.map((p) => typescript_1.factory.createLiteralTypeNode(typescript_1.factory.createStringLiteral(p))))),
        printProperty('pathString', typescript_1.factory.createStringLiteral(parsedLogic.pathString)),
        printProperty('props', (0, printProps_1.printProps)(parsedLogic)),
        printProperty('reducer', (0, printReducer_1.printReducer)(parsedLogic)),
        printProperty('reducerOptions', (0, printReducerOptions_1.printReducerOptions)(parsedLogic)),
        printProperty('reducers', (0, printReducers_1.printReducers)(parsedLogic)),
        printProperty('selector', (0, printSelector_1.printSelector)(parsedLogic)),
        printProperty('selectors', (0, printSelectors_1.printSelectors)(parsedLogic)),
        printProperty('sharedListeners', (0, printSharedListeners_1.printSharedListeners)(parsedLogic)),
        printProperty('values', (0, printValues_1.printValues)(parsedLogic)),
        printProperty('_isKea', typescript_1.factory.createTrue()),
        printProperty('_isKeaWithKey', parsedLogic.keyType ? typescript_1.factory.createTrue() : typescript_1.factory.createFalse()),
        addSelectorTypeHelp
            ? printProperty('__keaTypeGenInternalSelectorTypes', (0, printInternalSelectorTypes_1.printInternalSelectorTypes)(parsedLogic))
            : null,
        Object.keys(parsedLogic.extraActions).length > 0
            ? printProperty('__keaTypeGenInternalReducerActions', (0, printInternalReducerActions_1.printInternalReducerActions)(parsedLogic))
            : null,
        Object.keys(parsedLogic.extraInput).length > 0
            ? printProperty('__keaTypeGenInternalExtraInput', (0, printInternalExtraInput_1.printInternalExtraInput)(parsedLogic))
            : null,
    ].filter((a) => !!a);
    const logicTypeArguments = getLogicTypeArguments(parsedLogic);
    parsedLogic.interfaceDeclaration = typescript_1.factory.createInterfaceDeclaration(undefined, [typescript_1.factory.createModifier(typescript_1.SyntaxKind.ExportKeyword)], typescript_1.factory.createIdentifier(`${parsedLogic.logicName}Type`), logicTypeArguments, [
        typescript_1.factory.createHeritageClause(typescript_1.SyntaxKind.ExtendsKeyword, [
            typescript_1.factory.createExpressionWithTypeArguments(typescript_1.factory.createIdentifier('Logic'), undefined),
        ]),
    ], logicProperties);
}
exports.printLogicType = printLogicType;
let i = 0;
const smiles = ['/', ']', '[', ')', '(', '\\', 'D', '|', 'O'];
//# sourceMappingURL=print.js.map